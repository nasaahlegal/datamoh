from telegram import Update
from telegram.ext import ContextTypes, ConversationHandler
from config import (
    CATEGORIES, ANSWERS, FREE_QUESTIONS_LIMIT, QUESTION_PRICE,
    SINGLE_PAY_MSG, ADMIN_TELEGRAM_ID, ADMIN_USERNAME, SUPPORT_USERNAME,
    ABOUT_MSG, SUBSCRIPTION_PRICE, PAY_ACCOUNT, PAY_MSG
)
from keyboards import (
    get_main_menu_inline_markup, get_payment_reply_markup,
    get_back_main_markup, get_about_markup, get_free_confirm_markup,
    get_subscription_markup, get_admin_decision_markup, get_sub_admin_options_markup
)
from users import (
    create_or_get_user, decrement_free_questions,
    get_user, set_subscription, get_connection,
    get_active_subscriptions, extend_subscription, remove_subscription, is_subscribed
)
import time

CHOOSE_CATEGORY, CHOOSE_QUESTION, WAIT_PAYMENT, FREE_OR_SUB_CONFIRM, SUBSCRIPTION_FLOW = range(5)

admin_active_subs_cache = {}

WELCOME_MSG = (
    "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ *Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†ÙŠØ© Ø§Ù„Ø°ÙƒÙŠØ©*ØŒ Ø¥Ø­Ø¯Ù‰ Ø®Ø¯Ù…Ø§Øª *Ù…Ø­Ø§Ù…ÙŠ.ÙƒÙˆÙ…* âš–ï¸\n\n"
    "ØªØªÙŠØ­ Ù„Ùƒ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ *Ø¥Ø¬Ø§Ø¨Ø§Øª Ù‚Ø§Ù†ÙˆÙ†ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ© ÙˆØ³Ø±ÙŠØ¹Ø©*ØŒ Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ ÙÙŠ ÙÙ‡Ù… Ù…ÙˆÙ‚ÙÙƒ Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†ÙŠ ÙˆØ§ØªØ®Ø§Ø° Ù‚Ø±Ø§Ø±Ø§Øª ÙˆØ§Ø«Ù‚Ø©.\n\n"
    "ğŸ”’ Ù†Ø­Ù† Ù†Ø­ØªØ±Ù… Ø®ØµÙˆØµÙŠØªÙƒ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ØŒ ÙˆÙ„Ø§ Ù†Ø·Ù„Ø¨ Ø£ÙŠ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø´Ø®ØµÙŠØ©. ÙˆØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª ØªÙØ­Ø°Ù ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø©.\n\n"
    "ğŸ’³ *Ù†Ø¸Ø±Ù‹Ø§ Ù„Ø¹Ø¯Ù… ØªÙˆÙØ± Ù…Ù†ØµØ§Øª Ø¯ÙØ¹ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¹Ø±Ø§Ù‚ Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†*ØŒ Ù†Ø¹ØªÙ…Ø¯ Ø­Ø§Ù„ÙŠÙ‹Ø§ Ø¹Ù„Ù‰ *Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø¯ÙØ¹*:\n"
    "Ø£ÙŠ Ø£Ù†Ùƒ ØªÙ‚ÙˆÙ… Ø¨ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ØŒ Ø«Ù… ÙŠØªÙ… Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© ÙŠØ¯ÙˆÙŠÙ‹Ø§ Ù„Ù„Ù…ÙˆØ§ÙÙ‚Ø© ÙˆØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§.\n\n"
    "ğŸš€ Ù„ØªØ¬Ø§ÙˆØ² Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·ÙˆØ© Ù…Ø³ØªÙ‚Ø¨Ù„Ø§Ù‹ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø´Ù‡Ø±ÙŠ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©ØŒ ÙˆØ§Ù„Ø§Ø³ØªÙ…ØªØ§Ø¹ Ø¨Ø¹Ø¯Ø¯ ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯ Ù…Ù† Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„ÙÙˆØ±ÙŠØ© Ø¯ÙˆÙ† Ø§Ù„Ø­Ø§Ø¬Ø© Ø¥Ù„Ù‰ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© ÙÙŠ ÙƒÙ„ Ù…Ø±Ø©.\n\n"
    "ğŸ“² Ø§Ù„Ø¯ÙØ¹ Ù…ØªØ§Ø­ Ø­Ø§Ù„ÙŠÙ‹Ø§ Ø¹Ø¨Ø± ØªØ·Ø¨ÙŠÙ‚ *(ÙƒÙŠ)* Ø§Ù„Ù…Ø¹ØªÙ…Ø¯ Ù…Ù† Ù…ØµØ±Ù Ø§Ù„Ø±Ø§ÙØ¯ÙŠÙ†ØŒ ÙˆÙ†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªÙˆÙÙŠØ± Ø®ÙŠØ§Ø±Ø§Øª Ø¯ÙØ¹ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ© Ø£Ø®Ø±Ù‰ Ù‚Ø±ÙŠØ¨Ù‹Ø§.\n\n"
    "ğŸ‘‡ Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù„Ù„Ø¨Ø¯Ø¡:"
)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    create_or_get_user(user.id, user.username, user.full_name)
    await update.message.reply_text(
        WELCOME_MSG,
        reply_markup=get_main_menu_inline_markup(CATEGORIES),
        parse_mode="Markdown"
    )
    return CHOOSE_CATEGORY

async def main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        WELCOME_MSG,
        reply_markup=get_main_menu_inline_markup(CATEGORIES),
        parse_mode="Markdown"
    )
    return CHOOSE_CATEGORY

async def category_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    create_or_get_user(user.id, user.username, user.full_name)
    text = update.message.text
    
    if text == "Ø§Ø´ØªØ±Ø§Ùƒ Ø´Ù‡Ø±ÙŠ":
        return await subscription_handler(update, context)
    elif text in CATEGORIES:
        context.user_data["category"] = text
        questions = CATEGORIES[text]
        context.user_data["questions"] = questions
        numbered = "\n".join([f"{i+1}. {q}" for i, q in enumerate(questions)])
        await update.message.reply_text(
            f"Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…ØªÙˆÙØ±Ø© Ø¶Ù…Ù† Ù‚Ø³Ù… [{text}]:\n\n{numbered}\n\n"
            "Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø³Ø¤Ø§Ù„ Ù„Ù„Ø§Ø·Ù„Ø§Ø¹ Ø¹Ù„Ù‰ Ø¬ÙˆØ§Ø¨Ù‡ØŒ Ø£Ùˆ Ø£Ø±Ø³Ù„ (Ø±Ø¬ÙˆØ¹) Ø£Ùˆ (Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©) Ù„Ù„Ø¹ÙˆØ¯Ø©.",
            reply_markup=get_back_main_markup()
        )
        return CHOOSE_QUESTION
    elif text == "Ø¹Ù† Ø§Ù„Ù…Ù†ØµØ©":
        await update.message.reply_text(
            ABOUT_MSG,
            reply_markup=get_about_markup()
        )
        return CHOOSE_CATEGORY
    else:
        await update.message.reply_text(
            "ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØªØµÙ†ÙŠÙ ØµØ­ÙŠØ­.",
            reply_markup=get_main_menu_markup(CATEGORIES))
        return CHOOSE_CATEGORY

async def subscription_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_info = get_user(user.id)
    if is_subscribed(user.id):
        now = int(time.time())
        days_left = int((user_info["sub_expiry"] - now) // (24*60*60))
        await update.message.reply_text(
            f"Ù„Ø¯ÙŠÙƒ Ø§Ø´ØªØ±Ø§Ùƒ Ø´Ù‡Ø±ÙŠ ÙØ¹Ù‘Ø§Ù„ Ø¨Ø§Ù„ÙØ¹Ù„.\nØ¹Ø¯Ø¯ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: {days_left} ÙŠÙˆÙ…Ù‹Ø§.\n"
            "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¬Ù…ÙŠØ¹ Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ù†ØµØ©.",
            reply_markup=get_main_menu_markup(CATEGORIES)
        )
        return CHOOSE_CATEGORY
    await update.message.reply_text(
        "Ø§Ù‡Ù„Ø§ Ø¨Ùƒ ÙÙŠ Ø§Ù„Ø§Ø³ØªØ´Ø§Ø±Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù„Ù…Ù†ØµØ© Ù…Ø­Ø§Ù…ÙŠ.ÙƒÙˆÙ…\n\n"
        "ÙŠÙ…ÙƒÙ†Ùƒ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ø´Ù‡Ø±ÙŠ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø¯Ù…Ø© Ø¨Ù‚ÙŠÙ…Ø© 50,000 Ø¯ÙŠÙ†Ø§Ø± Ø¹Ø±Ø§Ù‚ÙŠ "
        "ÙˆØ§Ù„Ø§Ø³ØªÙ…ØªØ§Ø¹ Ø¨Ø¹Ø¯Ø¯ Ù„Ø§ Ù…Ø­Ø¯ÙˆØ¯ Ù…Ù† Ø§Ù„Ø§Ø¬Ø§Ø¨Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø§Ù„Ù…ØªÙˆÙØ±Ø© ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø³Ù…\n\n"
        "ØªØªÙ… Ø¯ÙØ¹ Ø±Ø³ÙˆÙ… Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¹Ø¨Ø± ØªØ·Ø¨ÙŠÙ‚ (ÙƒÙŠ) Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ… Ù…Ù† Ù‚Ø¨Ù„ Ù…ØµØ±Ù Ø§Ù„Ø±Ø§ÙØ¯ÙŠÙ†\n"
        "ÙˆØ³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø·Ø±Ù‚ Ù‚Ø±ÙŠØ¨Ø§\n\n"
        "Ù„Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ù…ÙˆØ§ÙÙ‚",
        reply_markup=get_subscription_markup()
    )
    return SUBSCRIPTION_FLOW

async def subscription_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    
    if text == "Ù…ÙˆØ§ÙÙ‚":
        await update.message.reply_text(
            "ÙŠØ±Ø¬Ù‰ ØªØ­ÙˆÙŠÙ„ Ø±Ø³ÙˆÙ… Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù‰ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ§Ù„ÙŠ:\n"
            "9916153415\n\n"
            "Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­ÙˆÙŠÙ„ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ (ØªÙ… Ø§Ù„ØªØ­ÙˆÙŠÙ„) ÙˆØ³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø®ØªØµ",
            reply_markup=get_payment_reply_markup()
        )
        context.user_data["subscription_request"] = True
        return WAIT_PAYMENT
    elif text == "Ø±Ø¬ÙˆØ¹":
        await main_menu_handler(update, context)
        return CHOOSE_CATEGORY
    else:
        await update.message.reply_text("ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…ØªÙˆÙØ±Ø© ÙÙ‚Ø·.")
        return SUBSCRIPTION_FLOW

async def question_number_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_info = get_user(user.id)
    questions = context.user_data.get("questions", [])
    
    try:
        idx = int(update.message.text) - 1
        if idx < 0 or idx >= len(questions):
            raise Exception()
    except Exception:
        await update.message.reply_text(
            "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.",
            reply_markup=get_back_main_markup()
        )
        return CHOOSE_QUESTION
    
    question = questions[idx]
    context.user_data["pending_answer"] = question

    if is_subscribed(user.id):
        await update.message.reply_text(
            f"Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©:\n{ANSWERS.get(question, 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø¬Ø§Ø¨Ø© Ù…Ø³Ø¬Ù„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„.')}\n\n"
            f"(Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ø§Ù„Ø´Ù‡Ø±ÙŠ ÙØ¹Ù‘Ø§Ù„ØŒ Ù…ØªØ¨Ù‚Ù Ù„Ùƒ {int((user_info['sub_expiry']-int(time.time()))//(24*60*60))} ÙŠÙˆÙ…)",
            reply_markup=get_main_menu_markup(CATEGORIES)
        )
        return CHOOSE_CATEGORY

    if user_info["free_questions_left"] > 0:
        await update.message.reply_text(
            f"Ù„Ø¯ÙŠÙƒ {user_info['free_questions_left']} Ø³Ø¤Ø§Ù„ Ù…Ø¬Ø§Ù†ÙŠ Ù…ØªØ¨Ù‚Ù.\n"
            "Ù‡Ù„ ØªØ±ØºØ¨ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø³Ø¤Ø§Ù„ Ù…Ø¬Ø§Ù†ÙŠ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ø¨ØŸ",
            reply_markup=get_free_confirm_markup()
        )
        context.user_data["awaiting_free_answer"] = True
        return FREE_OR_SUB_CONFIRM
    else:
        await update.message.reply_text(
            SINGLE_PAY_MSG,
            reply_markup=get_payment_reply_markup()
        )
        context.user_data["subscription_request"] = False
        return WAIT_PAYMENT

async def confirm_free_or_sub_use_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_info = get_user(user.id)
    pending_answer = context.user_data.get("pending_answer")

    if update.message.text == "Ù†Ø¹Ù…" and context.user_data.get("awaiting_free_answer"):
        decrement_free_questions(user.id)
        left = user_info['free_questions_left'] - 1
        await update.message.reply_text(
            f"Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©:\n{ANSWERS.get(pending_answer, 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø¬Ø§Ø¨Ø© Ù…Ø³Ø¬Ù„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø³Ø¤Ø§Ù„.')}\n\n(ØªØ¨Ù‚Ù‰ Ù„Ø¯ÙŠÙƒ {left} Ø³Ø¤Ø§Ù„ Ù…Ø¬Ø§Ù†ÙŠ)",
            reply_markup=get_main_menu_markup(CATEGORIES)
        )
        context.user_data.pop("awaiting_free_answer", None)
        return CHOOSE_CATEGORY
    elif update.message.text == "Ø±Ø¬ÙˆØ¹":
        cat = context.user_data.get("category")
        questions = CATEGORIES.get(cat, [])
        context.user_data["questions"] = questions
        numbered = "\n".join([f"{i+1}. {q}" for i, q in enumerate(questions)])
        await update.message.reply_text(
            f"Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…ØªÙˆÙØ±Ø© Ø¶Ù…Ù† Ù‚Ø³Ù… [{cat}]:\n\n{numbered}\n\n"
            "Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø³Ø¤Ø§Ù„ Ù„Ù„Ø§Ø·Ù„Ø§Ø¹ Ø¹Ù„Ù‰ Ø¬ÙˆØ§Ø¨Ù‡ØŒ Ø£Ùˆ Ø£Ø±Ø³Ù„ (Ø±Ø¬ÙˆØ¹) Ø£Ùˆ (Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©) Ù„Ù„Ø¹ÙˆØ¯Ø©.",
            reply_markup=get_back_main_markup()
        )
        context.user_data.pop("awaiting_free_answer", None)
        return CHOOSE_QUESTION
    elif update.message.text == "Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©":
        return await main_menu_handler(update, context)
    else:
        await update.message.reply_text("ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…ØªÙˆÙØ±Ø© ÙÙ‚Ø·.", reply_markup=get_free_confirm_markup())
        return FREE_OR_SUB_CONFIRM

async def back_to_questions_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    cat = context.user_data.get("category")
    questions = CATEGORIES.get(cat, [])
    context.user_data["questions"] = questions
    numbered = "\n".join([f"{i+1}. {q}" for i, q in enumerate(questions)])
    await update.message.reply_text(
        f"Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…ØªÙˆÙØ±Ø© Ø¶Ù…Ù† Ù‚Ø³Ù… [{cat}]:\n\n{numbered}\n\n"
        "Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø³Ø¤Ø§Ù„ Ù„Ù„Ø§Ø·Ù„Ø§Ø¹ Ø¹Ù„Ù‰ Ø¬ÙˆØ§Ø¨Ù‡ØŒ Ø£Ùˆ Ø£Ø±Ø³Ù„ (Ø±Ø¬ÙˆØ¹) Ø£Ùˆ (Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©) Ù„Ù„Ø¹ÙˆØ¯Ø©.",
        reply_markup=get_back_main_markup()
    )
    context.user_data.pop("awaiting_free_answer", None)
    return CHOOSE_QUESTION

async def payment_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    text = update.message.text
    user_id = user.id
    
    if text == "ØªÙ… Ø§Ù„ØªØ­ÙˆÙŠÙ„":
        if context.user_data.get("subscription_request", False):
            await update.message.reply_text(
                "âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ø¨Ù†Ø¬Ø§Ø­!\n"
                "Ø³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ­ÙˆÙŠÙ„.\n"
                "ÙŠÙ…ÙƒÙ†Ùƒ Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¢Ù†:",
                reply_markup=get_main_menu_markup(CATEGORIES)
            )
            await update.get_bot().send_message(
                chat_id=ADMIN_TELEGRAM_ID,
                text=f"ğŸ“¬ Ø·Ù„Ø¨ Ø§Ø´ØªØ±Ø§Ùƒ Ø¬Ø¯ÙŠØ¯:\n"
                     f"ğŸ‘¤ Ø§Ù„Ø§Ø³Ù…: {user.full_name}\n"
                     f"ğŸ”— Ø§Ù„Ù…Ø¹Ø±Ù: @{user.username or 'Ø¨Ø¯ÙˆÙ†'}\n"
                     f"ğŸ†” ID: {user.id}\n"
                     f"ğŸ’³ Ø§Ù„Ù…Ø¨Ù„Øº: 50,000 Ø¯ÙŠÙ†Ø§Ø± Ø¹Ø±Ø§Ù‚ÙŠ\n"
                     f"â³ Ø§Ù„Ù…Ø¯Ø©: 30 ÙŠÙˆÙ…",
                reply_markup=get_admin_decision_markup(user.id)
            )
        else:
            pending_answer = context.user_data.get("pending_answer", "Ø³Ø¤Ø§Ù„ ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
            await update.message.reply_text(
                "âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­!\n"
                "Ø³ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø³Ø¤Ø§Ù„Ùƒ Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ­ÙˆÙŠÙ„.\n"
                "ÙŠÙ…ÙƒÙ†Ùƒ Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¢Ù†:",
                reply_markup=get_main_menu_markup(CATEGORIES)
            )
            await update.get_bot().send_message(
                chat_id=ADMIN_TELEGRAM_ID,
                text=f"ğŸ“¬ Ø·Ù„Ø¨ Ø¯ÙØ¹ Ù„Ø³Ø¤Ø§Ù„:\n"
                     f"ğŸ‘¤ Ø§Ù„Ø§Ø³Ù…: {user.full_name}\n"
                     f"ğŸ”— Ø§Ù„Ù…Ø¹Ø±Ù: @{user.username or 'Ø¨Ø¯ÙˆÙ†'}\n"
                     f"ğŸ†” ID: {user.id}\n"
                     f"â“ Ø§Ù„Ø³Ø¤Ø§Ù„: {pending_answer}",
            )
        
        context.user_data.pop("pending_answer", None)
        context.user_data.pop("subscription_request", None)
        return CHOOSE_CATEGORY
        
    elif text == "Ø§Ù„ØºØ§Ø¡":
        await update.message.reply_text(
            "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¯ÙØ¹.\n"
            "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:",
            reply_markup=get_main_menu_markup(CATEGORIES)
        )
        return CHOOSE_CATEGORY
        
    else:
        await update.message.reply_text("ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙÙ‚Ø·.", reply_markup=get_payment_reply_markup())
        return WAIT_PAYMENT

async def handle_admin_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    data = query.data
    user_id = int(data.split('_')[1])

    if data.startswith("accept_"):
        set_subscription(user_id, "", "", 30)
        await query.edit_message_text(f"âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}")
        await context.bot.send_message(
            chat_id=user_id,
            text="ğŸ‰ ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ø¨Ù†Ø¬Ø§Ø­ Ù„Ù…Ø¯Ø© 30 ÙŠÙˆÙ…Ù‹Ø§!\n"
                 "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø¨Ø¯ÙˆÙ† Ù‚ÙŠÙˆØ¯."
        )
    elif data.startswith("reject_"):
        await query.edit_message_text(f"âŒ ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {user_id}")
        await context.bot.send_message(
            chat_id=user_id,
            text="âš ï¸ ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ø§Ù„Ø¬Ø¯ÙŠØ¯.\n"
                 "Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯ÙŠÙƒ Ø§Ø´ØªØ±Ø§Ùƒ ÙØ¹Ù‘Ø§Ù„ Ø­Ø§Ù„ÙŠÙ‹Ø§ØŒ Ù…Ø§Ø²Ø§Ù„ Ø¨Ø¥Ù…ÙƒØ§Ù†Ùƒ Ø§Ù„Ø§Ø³ØªÙØ§Ø¯Ø© Ù…Ù†Ù‡ Ø­ØªÙ‰ Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ø¯ØªÙ‡.\n"
                 "ÙÙŠ Ø­Ø§Ù„ ÙˆØ¬ÙˆØ¯ Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ @mohamycom"
        )
# Ù„ÙƒÙ† Ø¹Ù†Ø¯ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø¶ØºØ· Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙŠØ¬Ø¨ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ callback_data
from telegram.ext import CallbackQueryHandler

async def main_menu_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    text = query.data

    # Ù†ÙØ³ Ù…Ù†Ø·Ù‚ category_handler Ù„ÙƒÙ† Ù…Ø¹ text Ù…Ù† query.data
    if text == "Ø§Ø´ØªØ±Ø§Ùƒ Ø´Ù‡Ø±ÙŠ":
        await subscription_handler(update, context)
    elif text in CATEGORIES:
        context.user_data["category"] = text
        questions = CATEGORIES[text]
        context.user_data["questions"] = questions
        numbered = "\n".join([f"{i+1}. {q}" for i, q in enumerate(questions)])
        await query.message.reply_text(
            f"Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…ØªÙˆÙØ±Ø© Ø¶Ù…Ù† Ù‚Ø³Ù… [{text}]:\n\n{numbered}\n\n"
            "Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ø³Ø¤Ø§Ù„ Ù„Ù„Ø§Ø·Ù„Ø§Ø¹ Ø¹Ù„Ù‰ Ø¬ÙˆØ§Ø¨Ù‡ØŒ Ø£Ùˆ Ø£Ø±Ø³Ù„ (Ø±Ø¬ÙˆØ¹) Ø£Ùˆ (Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©) Ù„Ù„Ø¹ÙˆØ¯Ø©.",
            reply_markup=get_back_main_markup()
        )
    elif text == "Ø¹Ù† Ø§Ù„Ù…Ù†ØµØ©":
        await query.message.reply_text(
            ABOUT_MSG,
            reply_markup=get_about_markup()
        )
    else:
        await query.message.reply_text(
            "ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØªØµÙ†ÙŠÙ ØµØ­ÙŠØ­.",
            reply_markup=get_main_menu_inline_markup(CATEGORIES)
        )